import { Issue } from '@linear/sdk';

/**
 * Format Linear issue for workflow context
 */
export async function formatIssueContext(issue: Issue): Promise<Record<string, any>> {
  const state = await issue.state;
  const assignee = await issue.assignee;
  const creator = await issue.creator;

  return {
    id: issue.id,
    identifier: issue.identifier,
    title: issue.title,
    description: issue.description || '',
    url: issue.url,
    priority: issue.priority,
    state: state?.name,
    assignee: assignee?.name,
    creator: creator?.name,
    createdAt: issue.createdAt,
    updatedAt: issue.updatedAt,
  };
}

/**
 * Format workflow execution result as a Linear issue comment
 */
export function formatWorkflowResultComment(result: {
  workflowId: string;
  status: string;
  duration?: number;
  totalCost?: number;
  error?: string;
  currentStep?: number;
  totalSteps?: number;
}): string {
  const lines = [];

  // Header
  if (result.status === 'completed') {
    lines.push('## ✅ Claude Code Workflow Completed');
  } else if (result.status === 'failed') {
    lines.push('## ❌ Claude Code Workflow Failed');
  } else {
    lines.push('## ⚠️ Claude Code Workflow Status');
  }

  lines.push('');

  // Details
  lines.push('### Execution Details');
  lines.push('');
  lines.push(`- **Workflow ID:** \`${result.workflowId}\``);
  lines.push(`- **Status:** ${result.status}`);

  if (result.currentStep !== undefined && result.totalSteps !== undefined) {
    lines.push(`- **Progress:** Step ${result.currentStep}/${result.totalSteps}`);
  }

  if (result.duration !== undefined) {
    const durationSec = (result.duration / 1000).toFixed(2);
    lines.push(`- **Duration:** ${durationSec}s`);
  }

  if (result.totalCost !== undefined) {
    const costDollars = (result.totalCost / 100).toFixed(2);
    lines.push(`- **Cost:** $${costDollars}`);
  }

  if (result.error) {
    lines.push('');
    lines.push('### Error');
    lines.push('```');
    lines.push(result.error);
    lines.push('```');
  }

  lines.push('');
  lines.push('---');
  lines.push('*Generated by Claude Code Service*');

  return lines.join('\n');
}

/**
 * Format issue creation result for notifications
 */
export function formatIssueCreated(issue: {
  id: string;
  identifier: string;
  title: string;
  url: string;
  teamName?: string;
}): { text: string; blocks?: any[] } {
  const text = `Linear issue created: ${issue.identifier} - ${issue.title}\n${issue.url}`;

  const blocks = [
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Linear Issue Created*\n\n*${issue.identifier}:* ${issue.title}`,
      },
    },
    {
      type: 'section',
      fields: [
        {
          type: 'mrkdwn',
          text: `*Team:*\n${issue.teamName || 'Unknown'}`,
        },
        {
          type: 'mrkdwn',
          text: `*URL:*\n<${issue.url}|View in Linear>`,
        },
      ],
    },
  ];

  return { text, blocks };
}

/**
 * Format issue update result for notifications
 */
export function formatIssueUpdated(issue: {
  identifier: string;
  title: string;
  url: string;
  changes: string[];
}): { text: string; blocks?: any[] } {
  const changesText = issue.changes.join(', ');
  const text = `Linear issue updated: ${issue.identifier}\nChanges: ${changesText}\n${issue.url}`;

  const blocks = [
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Linear Issue Updated*\n\n*${issue.identifier}:* ${issue.title}`,
      },
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Changes:* ${changesText}`,
      },
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `<${issue.url}|View in Linear>`,
      },
    },
  ];

  return { text, blocks };
}

/**
 * Format issue summary for readable display
 */
export async function formatIssueSummary(issue: Issue): Promise<string> {
  const state = await issue.state;
  const assignee = await issue.assignee;
  const creator = await issue.creator;
  const project = await issue.project;

  const lines = [];

  lines.push(`# ${issue.identifier}: ${issue.title}`);
  lines.push('');

  if (issue.description) {
    lines.push('## Description');
    lines.push(issue.description);
    lines.push('');
  }

  lines.push('## Details');
  lines.push(`- **Status:** ${state?.name || 'Unknown'}`);
  lines.push(`- **Priority:** ${getPriorityLabel(issue.priority)}`);

  if (assignee) {
    lines.push(`- **Assignee:** ${assignee.name}`);
  }

  if (creator) {
    lines.push(`- **Creator:** ${creator.name}`);
  }

  if (project) {
    lines.push(`- **Project:** ${project.name}`);
  }

  lines.push(`- **Created:** ${new Date(issue.createdAt).toLocaleString()}`);
  lines.push(`- **Updated:** ${new Date(issue.updatedAt).toLocaleString()}`);
  lines.push(`- **URL:** ${issue.url}`);

  return lines.join('\n');
}

/**
 * Get human-readable priority label
 */
function getPriorityLabel(priority: number): string {
  switch (priority) {
    case 0:
      return 'No Priority';
    case 1:
      return 'Urgent';
    case 2:
      return 'High';
    case 3:
      return 'Medium';
    case 4:
      return 'Low';
    default:
      return `Priority ${priority}`;
  }
}

/**
 * Format Linear webhook event for logging
 */
export function formatWebhookEvent(event: {
  type: string;
  action: string;
  issueIdentifier?: string;
  timestamp: Date;
}): string {
  const parts = [
    `[Linear Webhook]`,
    event.type,
    event.action,
  ];

  if (event.issueIdentifier) {
    parts.push(`(${event.issueIdentifier})`);
  }

  parts.push(`at ${event.timestamp.toISOString()}`);

  return parts.join(' ');
}

/**
 * Format integration config for display
 */
export function formatIntegrationConfig(config: {
  projectId: number;
  linearTeamId: string;
  linearTeamName?: string;
  eventTypes: string[];
  isActive: boolean;
}): string {
  const lines = [];

  lines.push('## Linear Integration Configuration');
  lines.push('');
  lines.push(`- **Status:** ${config.isActive ? '✅ Active' : '❌ Inactive'}`);
  lines.push(`- **Project ID:** ${config.projectId}`);
  lines.push(`- **Linear Team:** ${config.linearTeamName || config.linearTeamId}`);
  lines.push(`- **Enabled Events:**`);

  config.eventTypes.forEach(eventType => {
    lines.push(`  - ${eventType}`);
  });

  return lines.join('\n');
}

/**
 * Parse Linear issue URL to extract issue ID or identifier
 */
export function parseLinearIssueUrl(url: string): { issueIdentifier?: string; teamKey?: string } | null {
  // Linear URLs are typically: https://linear.app/{workspace}/issue/{TEAM-123}
  const match = url.match(/linear\.app\/[^/]+\/issue\/([A-Z]+-\d+)/i);

  if (match) {
    const identifier = match[1];
    const teamKey = identifier.split('-')[0];
    return { issueIdentifier: identifier, teamKey };
  }

  return null;
}

/**
 * Format error message for Linear comment
 */
export function formatErrorComment(error: string, workflowId?: string): string {
  const lines = [];

  lines.push('## ❌ Claude Code Error');
  lines.push('');
  lines.push('An error occurred while processing this issue:');
  lines.push('');
  lines.push('```');
  lines.push(error);
  lines.push('```');
  lines.push('');

  if (workflowId) {
    lines.push(`**Workflow ID:** \`${workflowId}\``);
    lines.push('');
  }

  lines.push('---');
  lines.push('*Generated by Claude Code Service*');

  return lines.join('\n');
}
